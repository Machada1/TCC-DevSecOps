# cloudbuild.yaml
# Pipeline completo: build -> push -> segurança -> deploy -> teste dinâmico

substitutions:
  _ARTIFACT_REPO: "devsecops-repo"
  _REGION: "us-central1"
  _PROJECT_ID: "infra-sd-host"
  _CLUSTER_NAME: "devsecops-cluster"
  _APP_NAME: "dvwa-app"
  _DEPLOYMENT_NAME: "dvwa-app"
  _REPORT_BUCKET: "gs://devsecops-reports-dvwa"
  _LOGS_BUCKET: "gs://infra-sd-host-cloudbuild-logs"
  _SOURCE_IMAGE: "vulnerables/web-dvwa:latest"

steps:
  # 0 Criar diretório de relatórios
  - name: 'ubuntu'
    id: 'setup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        mkdir -p /workspace/reports/dependency-check
        echo "Diretório de relatórios criado"

  # 1 Pull da imagem DVWA pública
  - name: 'gcr.io/cloud-builders/docker'
    id: 'pull-dvwa'
    args:
      - 'pull'
      - '${_SOURCE_IMAGE}'
    waitFor: ['setup']

  # 2 Tag e push da imagem para o Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-dvwa'
    args:
      - 'tag'
      - '${_SOURCE_IMAGE}'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['pull-dvwa']

  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['push-dvwa']
    
  # 3 SAST com Semgrep (análise estática)
  - name: 'returntocorp/semgrep:latest'
    id: 'semgrep'
    entrypoint: 'semgrep'
    args:
      - '--config'
      - 'auto'
      - '--json'
      - '--output'
      - '/workspace/reports/semgrep-report.json'
      - '.'
    waitFor:
      - 'push'

  # 4 SCA - Análise de Composição de Software

  # NOTA: OWASP Dependency-Check comentado pois sem NVD API Key o download
  # da base de vulnerabilidades leva várias horas, inviabilizando o pipeline.
  # Para usar, obtenha uma API key gratuita em: https://nvd.nist.gov/developers/request-an-api-key
  # e adicione o argumento: '--nvdApiKey', '${_NVD_API_KEY}'
  #
  # - name: 'owasp/dependency-check'
  #   id: 'dependency-check'
  #   args:
  #     - '--scan'
  #     - '.'
  #     - '--format'
  #     - 'ALL'
  #     - '--out'
  #     - '/workspace/reports/dependency-check'
  #   waitFor:
  #     - 'push'
  
  # Alternativa: Trivy FS para SCA (mais rápido, usa base própria)
  - name: 'aquasec/trivy'
    id: 'sca-scan'
    args:
      - 'fs'
      - '--format'
      - 'json'
      - '--output'
      - '/workspace/reports/trivy-sca-report.json'
      - '.'
    waitFor:
      - 'push'

  # 5 IaC Scan (Terraform) com Checkov
  - name: 'bridgecrew/checkov:latest'
    id: 'checkov'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Escaneia tanto o Terraform quanto os manifests Kubernetes
        checkov -d ./Instrumentos/Codigos/DevSecOps/infra -o json > /workspace/reports/checkov-terraform.json || true
        checkov -d ./Instrumentos/Codigos/DevSecOps/dvwa/k8s -o json > /workspace/reports/checkov-k8s.json || true
        # Combina os relatórios
        echo '{"terraform": ' > /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-terraform.json >> /workspace/reports/checkov-report.json
        echo ', "kubernetes": ' >> /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-k8s.json >> /workspace/reports/checkov-report.json
        echo '}' >> /workspace/reports/checkov-report.json
        echo "Checkov scan completo"
    waitFor:
      - 'push'

  # 6 Container Scan (Trivy)
  - name: 'aquasec/trivy'
    id: 'trivy'
    args:
      - 'image'
      - '--format'
      - 'json'
      - '--output'
      - '/workspace/reports/trivy-report.json'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor:
      - 'push'

  # 6.1 Deploy do MySQL no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy-mysql'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/mysql.yaml
        echo "Aguardando o MySQL iniciar..."
        sleep 30
    waitFor:
      - 'trivy'


  # 7 Deploy no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        # Substituir placeholder da imagem no YAML
        sed -i "s|us-central1-docker.pkg.dev/PROJECT_ID/artifact-repo/dvwa-app:latest|${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA|g" Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        # Aplicar o deployment
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        echo "Aguardando pods ficarem prontos..."
        kubectl rollout status deployment/${_DEPLOYMENT_NAME} --timeout=120s
    waitFor:
      - 'deploy-mysql'

  # 8 Obter IP externo do serviço para DAST
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-external-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        echo "Aguardando LoadBalancer obter IP externo..."
        for i in {1..30}; do
          EXTERNAL_IP=$$(kubectl get svc dvwa-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -n "$$EXTERNAL_IP" ] && [ "$$EXTERNAL_IP" != "" ]; then
            echo "IP externo obtido: $$EXTERNAL_IP"
            echo "$$EXTERNAL_IP" > /workspace/external_ip.txt
            break
          fi
          echo "Tentativa $$i/30 - Aguardando IP..."
          sleep 10
        done
        if [ ! -f /workspace/external_ip.txt ]; then
          echo "ERRO: Não foi possível obter IP externo"
          echo "UNAVAILABLE" > /workspace/external_ip.txt
        fi
    waitFor:
      - 'deploy'

  # 9 DAST com OWASP ZAP (testes dinâmicos de segurança)
  # NOTA: A imagem mudou de owasp/zap2docker-stable para ghcr.io/zaproxy/zaproxy
  - name: 'ghcr.io/zaproxy/zaproxy:stable'
    id: 'zap-scan'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando scan DAST"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-report.json
          exit 0
        fi
        TARGET_URL="http://$$EXTERNAL_IP"
        echo "Alvo do scan DAST: $$TARGET_URL"
        
        # Aguardar app ficar disponível
        echo "Verificando se DVWA está acessível..."
        for i in {1..12}; do
          if curl -s --connect-timeout 5 "$$TARGET_URL" > /dev/null 2>&1; then
            echo "DVWA está acessível!"
            break
          fi
          echo "Tentativa $$i/12 - Aguardando DVWA..."
          sleep 10
        done
        
        # Executar scan baseline do ZAP
        echo "Iniciando OWASP ZAP Baseline Scan..."
        zap-baseline.py -t "$$TARGET_URL" -r /workspace/reports/zap-report.html -J /workspace/reports/zap-report.json -I || true
        echo "Scan ZAP concluído"
    waitFor:
      - 'get-external-ip'

  # 10 Upload dos relatórios de segurança para bucket GCS
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'upload-reports'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Relatórios gerados ==="
        ls -la /workspace/reports/
        # Nome da pasta: reports-<commit> (ex: reports-fbce037)
        if [ -d "/workspace/reports" ]; then
          gsutil -m cp -r /workspace/reports/* ${_REPORT_BUCKET}/reports-${SHORT_SHA}/
          echo "=============================================="
          echo "Relatórios salvos em: ${_REPORT_BUCKET}/reports-${SHORT_SHA}/"
          echo "=============================================="
        else
          echo "Nenhum relatório gerado."
        fi
    waitFor:
      - 'zap-scan'
      - 'semgrep'
      - 'sca-scan'
      - 'checkov'
      - 'trivy'

  # 11 Exibir IP externo do DVWA
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-service-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl get svc dvwa-service -o wide
    waitFor:
      - 'deploy'


images:
  - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'

options:
  dynamicSubstitutions: true
  defaultLogsBucketBehavior: REGIONAL_USER_OWNED_BUCKET
