
# cloudbuild.yaml
# Pipeline completo: build -> push -> segurança -> deploy -> teste dinâmico
substitutions:
  _ARTIFACT_REPO: "devsecops-repo"
  _REGION: "us-central1"
  _PROJECT_ID: "infra-sd-host"
  _CLUSTER_NAME: "devsecops-cluster"
  _APP_NAME: "dvwa-app"
  _DEPLOYMENT_NAME: "dvwa-app"
  _REPORT_BUCKET: "gs://devsecops-reports-dvwa"
  _LOGS_BUCKET: "gs://infra-sd-host-cloudbuild-logs"
  _SOURCE_IMAGE: "vulnerables/web-dvwa:latest"
  _DVWA_USER: "admin"
  _DVWA_PASS: "password"

steps:
  # 0 Criar diretório de relatórios
  - name: 'ubuntu'
    id: 'setup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        mkdir -p /workspace/reports/dependency-check
        echo "Diretório de relatórios criado"

  # 1 Pull da imagem DVWA pública
  - name: 'gcr.io/cloud-builders/docker'
    id: 'pull-dvwa'
    args:
      - 'pull'
      - '${_SOURCE_IMAGE}'
    waitFor: ['setup']

  # 2 Tag e push da imagem para o Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-dvwa'
    args:
      - 'tag'
      - '${_SOURCE_IMAGE}'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['pull-dvwa']

  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['push-dvwa']
    
  # 3 SAST com Semgrep (análise estática)
  - name: 'returntocorp/semgrep:latest'
    id: 'semgrep'
    entrypoint: 'semgrep'
    args:
      - '--config'
      - 'auto'
      - '--json'
      - '--output'
      - '/workspace/reports/semgrep-report.json'
      - '.'
    waitFor:
      - 'push'

  # 4 SCA - Análise de Composição de Software

  # NOTA: OWASP Dependency-Check comentado pois sem NVD API Key o download
  # da base de vulnerabilidades leva várias horas, inviabilizando o pipeline.
  # Para usar, obtenha uma API key gratuita em: https://nvd.nist.gov/developers/request-an-api-key
  # e adicione o argumento: '--nvdApiKey', '${_NVD_API_KEY}'
  #
  # - name: 'owasp/dependency-check'
  #   id: 'dependency-check'
  #   args:
  #     - '--scan'
  #     - '.'
  #     - '--format'
  #     - 'ALL'
  #     - '--out'
  #     - '/workspace/reports/dependency-check'
  #   waitFor:
  #     - 'push'
  
  # Alternativa: Trivy FS para SCA (mais rápido, usa base própria)
  - name: 'aquasec/trivy'
    id: 'sca-scan'
    args:
      - 'fs'
      - '--format'
      - 'json'
      - '--output'
      - '/workspace/reports/trivy-sca-report.json'
      - '.'
    waitFor:
      - 'push'

  # 5 IaC Scan (Terraform) com Checkov
  - name: 'bridgecrew/checkov:latest'
    id: 'checkov'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Escaneia tanto o Terraform quanto os manifests Kubernetes
        checkov -d ./Instrumentos/Codigos/DevSecOps/infra -o json > /workspace/reports/checkov-terraform.json || true
        checkov -d ./Instrumentos/Codigos/DevSecOps/dvwa/k8s -o json > /workspace/reports/checkov-k8s.json || true
        # Combina os relatórios
        echo '{"terraform": ' > /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-terraform.json >> /workspace/reports/checkov-report.json
        echo ', "kubernetes": ' >> /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-k8s.json >> /workspace/reports/checkov-report.json
        echo '}' >> /workspace/reports/checkov-report.json
        echo "Checkov scan completo"
    waitFor:
      - 'push'

  # 6 Container Scan (Trivy)
  - name: 'aquasec/trivy'
    id: 'trivy'
    args:
      - 'image'
      - '--format'
      - 'json'
      - '--output'
      - '/workspace/reports/trivy-report.json'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor:
      - 'push'

  # 7 Deploy do MySQL no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy-mysql'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/mysql.yaml
        echo "Aguardando o MySQL iniciar..."
        sleep 30
    waitFor:
      - 'trivy'


  # 8 Deploy do DVWA no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        # Substituir placeholder da imagem no YAML
        sed -i "s|us-central1-docker.pkg.dev/PROJECT_ID/artifact-repo/dvwa-app:latest|${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA|g" Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        # Aplicar o deployment
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        echo "Aguardando pods ficarem prontos..."
        kubectl rollout status deployment/${_DEPLOYMENT_NAME} --timeout=120s
    waitFor:
      - 'deploy-mysql'

  # 9 Obter IP externo do serviço para DAST
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-external-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        echo "Aguardando LoadBalancer obter IP externo..."
        for i in {1..30}; do
          EXTERNAL_IP=$$(kubectl get svc dvwa-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -n "$$EXTERNAL_IP" ] && [ "$$EXTERNAL_IP" != "" ]; then
            echo "IP externo obtido: $$EXTERNAL_IP"
            echo "$$EXTERNAL_IP" > /workspace/external_ip.txt
            break
          fi
          echo "Tentativa $$i/30 - Aguardando IP..."
          sleep 10
        done
        if [ ! -f /workspace/external_ip.txt ]; then
          echo "ERRO: Não foi possível obter IP externo"
          echo "UNAVAILABLE" > /workspace/external_ip.txt
        fi
    waitFor:
      - 'deploy'

  # 10 DAST com OWASP ZAP (testes dinâmicos de segurança)
  # NOTA: Usa docker para montar /workspace/reports como /zap/wrk
  - name: 'gcr.io/cloud-builders/docker'
    id: 'zap-scan'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando scan DAST"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-report.json
          exit 0
        fi
        TARGET_URL="http://$$EXTERNAL_IP"
        echo "Alvo do scan DAST: $$TARGET_URL"
        
        # Aguardar app ficar disponível
        echo "Verificando se DVWA está acessível..."
        for i in {1..12}; do
          if curl -s --connect-timeout 5 "$$TARGET_URL" > /dev/null 2>&1; then
            echo "DVWA está acessível!"
            break
          fi
          echo "Tentativa $$i/12 - Aguardando DVWA..."
          sleep 10
        done
        
        # Executar ZAP via Docker com volume montado (rodar como root para permissões)
        echo "Iniciando OWASP ZAP Baseline Scan..."
        docker run --rm \
          -u 0 \
          -v /workspace/reports:/zap/wrk:rw \
          -t ghcr.io/zaproxy/zaproxy:stable \
          zap-full-scan.py -t "$$TARGET_URL" -r zap-report.html -J zap-report.json -I || true
        
        echo "Scan ZAP concluído"
        ls -la /workspace/reports/zap* 2>/dev/null || echo "Nenhum relatório ZAP encontrado"
    waitFor:
      - 'get-external-ip'

  # 11 ZAP autenticado + active scan
  - name: 'ghcr.io/zaproxy/zaproxy:stable'
    id: 'zap-auth-active-scan'
    entrypoint: 'sh'
    args:
      - -c
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando ZAP autenticado"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-auth-report.json
          exit 0
        fi
        TARGET_URL="http://$$EXTERNAL_IP/login.php"
        # Instala zap-cli apenas com pip3 --user
        pip3 install --user zapcli
        # Inicia ZAP em modo daemon
        zap.sh -daemon -port 8090 -host 0.0.0.0 -config api.disablekey=true &
        sleep 30
        # Login automatizado (ajuste conforme necessário)
        curl -c /workspace/cookie.txt -d "username=${_DVWA_USER}&password=${_DVWA_PASS}&Login=Login" "$$TARGET_URL"
        # Importa cookie para ZAP
        ~/.local/bin/zap-cli --zap-url http://localhost:8090 --api-key '' load-cookies /workspace/cookie.txt http://$$EXTERNAL_IP
        # Active scan autenticado
        ~/.local/bin/zap-cli --zap-url http://localhost:8090 --api-key '' active-scan http://$$EXTERNAL_IP
        # Exporta relatório
        ~/.local/bin/zap-cli --zap-url http://localhost:8090 --api-key '' report -o /workspace/reports/zap-auth-active-report.html -f html
        ~/.local/bin/zap-cli --zap-url http://localhost:8090 --api-key '' report -o /workspace/reports/zap-auth-active-report.json -f json
        echo "ZAP autenticado + active scan concluído"
    waitFor:
      - 'get-external-ip'

  # 12 Teste de Brute Force com Hydra
  - name: 'gcr.io/cloud-builders/docker'
    id: 'hydra-bruteforce'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando brute force"
          echo '{"error": "IP não disponível"}' > /workspace/reports/hydra-bruteforce.json
          exit 0
        fi
        # Cria wordlist realista baseada nos secrets do DVWA/MySQL
        cat > /workspace/wordlist.txt <<EOF
        admin
        password
        root
        dvwa
        123456
        1234
        test
        guest
        user
        passw0rd
        admin123
        password123
        EOF
        # Remove linhas em branco e espaços extras
        sed -i 's/^[[:space:]]*//;s/[[:space:]]*$$//' /workspace/wordlist.txt
        sed -i '/^$$/d' /workspace/wordlist.txt
        
        echo "Iniciando Hydra brute force em $$EXTERNAL_IP..."
        # Executa Hydra via Docker (imagem oficial)
        docker run --rm \
          -v /workspace:/workspace \
          vanhauser/thc-hydra \
          -L /workspace/wordlist.txt \
          -P /workspace/wordlist.txt \
          -o /workspace/reports/hydra-bruteforce.txt \
          $$EXTERNAL_IP \
          http-post-form "/login.php:username=^USER^&password=^PASS^&Login=Login failed" \
          -f -w 10 -t 4 || true
        
        # Converte para JSON básico
        if [ -f /workspace/reports/hydra-bruteforce.txt ]; then
          echo '{"results": "' > /workspace/reports/hydra-bruteforce.json
          cat /workspace/reports/hydra-bruteforce.txt | tr '\n' ' ' >> /workspace/reports/hydra-bruteforce.json
          echo '"}' >> /workspace/reports/hydra-bruteforce.json
        else
          echo '{"results": "Nenhuma credencial encontrada ou erro na execução"}' > /workspace/reports/hydra-bruteforce.json
        fi
        echo "Hydra brute force concluído"
    waitFor:
      - 'get-external-ip'

  # 13 Upload dos relatórios de segurança para bucket GCS
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'upload-reports'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Relatórios gerados ==="
        ls -la /workspace/reports/
        # Nome da pasta: reports-<commit> (ex: reports-fbce037)
        if [ -d "/workspace/reports" ]; then
          gsutil -m cp -r /workspace/reports/* ${_REPORT_BUCKET}/reports-${SHORT_SHA}/
          echo "=============================================="
          echo "Relatórios salvos em: ${_REPORT_BUCKET}/reports-${SHORT_SHA}/"
          echo "=============================================="
        else
          echo "Nenhum relatório gerado."
        fi
    waitFor:
      - 'zap-scan'
      - 'semgrep'
      - 'sca-scan'
      - 'checkov'
      - 'trivy'

  # 14 Exibir IP externo do DVWA
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-service-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl get svc dvwa-service -o wide
    waitFor:
      - 'deploy'


images:
  - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'

options:
  dynamicSubstitutions: true
  defaultLogsBucketBehavior: REGIONAL_USER_OWNED_BUCKET
