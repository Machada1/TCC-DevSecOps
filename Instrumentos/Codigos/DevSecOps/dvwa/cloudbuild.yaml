
# cloudbuild.yaml
# Pipeline completo: build -> push -> segurança -> deploy -> teste dinâmico
substitutions:
  _ARTIFACT_REPO: "devsecops-repo"
  _REGION: "us-central1"
  _PROJECT_ID: "infra-sd-host"
  _CLUSTER_NAME: "devsecops-cluster"
  _APP_NAME: "dvwa-app"
  _DEPLOYMENT_NAME: "dvwa-app"
  _REPORT_BUCKET: "gs://devsecops-reports-dvwa"
  _LOGS_BUCKET: "gs://infra-sd-host-cloudbuild-logs"
  _SOURCE_IMAGE: "vulnerables/web-dvwa:latest"
  _DVWA_USER: "admin"
  _DVWA_PASS: "password"

steps:
  # 0 Criar diretório de relatórios
  - name: 'ubuntu'
    id: 'setup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        mkdir -p /workspace/reports/dependency-check
        echo "Diretório de relatórios criado"

  # 1 Pull da imagem DVWA pública
  - name: 'gcr.io/cloud-builders/docker'
    id: 'pull-dvwa'
    args:
      - 'pull'
      - '${_SOURCE_IMAGE}'
    waitFor: ['setup']

  # 2 Tag e push da imagem para o Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-dvwa'
    args:
      - 'tag'
      - '${_SOURCE_IMAGE}'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['pull-dvwa']

  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['push-dvwa']
    
  # 3 SAST com Semgrep (análise estática do código PHP do DVWA)
  - name: 'returntocorp/semgrep:latest'
    id: 'semgrep'
    entrypoint: 'semgrep'
    args:
      - '--config'
      - 'auto'
      - '--config'
      - 'p/php'              # Regras específicas PHP
      - '--config'
      - 'p/security-audit'   # Auditoria de segurança
      - '--config'
      - 'p/owasp-top-ten'    # OWASP Top 10
      - '--json'
      - '--output'
      - '/workspace/reports/semgrep-report.json'
      - 'Instrumentos/Codigos/DevSecOps/dvwa/src'  # Código-fonte DVWA
    waitFor:
      - 'push'

  # 4 SCA - Análise de Composição de Software

  # NOTA: OWASP Dependency-Check comentado pois sem NVD API Key o download
  # da base de vulnerabilidades leva várias horas, inviabilizando o pipeline.
  # Para usar, obtenha uma API key gratuita em: https://nvd.nist.gov/developers/request-an-api-key
  # e adicione o argumento: '--nvdApiKey', '${_NVD_API_KEY}'
  #
  # - name: 'owasp/dependency-check'
  #   id: 'dependency-check'
  #   args:
  #     - '--scan'
  #     - '.'
  #     - '--format'
  #     - 'ALL'
  #     - '--out'
  #     - '/workspace/reports/dependency-check'
  #   waitFor:
  #     - 'push'
  
  # Alternativa: Trivy FS para SCA (mais rápido, usa base própria)
  # Analisa código-fonte DVWA para encontrar dependências vulneráveis
  - name: 'aquasec/trivy'
    id: 'sca-scan'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        trivy fs \
          --scanners vuln,secret \
          --format json \
          --output /workspace/reports/trivy-sca-report.json \
          --db-repository ghcr.io/aquasecurity/trivy-db \
          --skip-db-update=false \
          Instrumentos/Codigos/DevSecOps/dvwa/src || \
        echo '{"Results":[]}' > /workspace/reports/trivy-sca-report.json
    waitFor:
      - 'push'

  # 5 IaC Scan (Terraform) com Checkov
  - name: 'bridgecrew/checkov:latest'
    id: 'checkov'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Escaneia tanto o Terraform quanto os manifests Kubernetes
        checkov -d ./Instrumentos/Codigos/DevSecOps/infra -o json > /workspace/reports/checkov-terraform.json || true
        checkov -d ./Instrumentos/Codigos/DevSecOps/dvwa/k8s -o json > /workspace/reports/checkov-k8s.json || true
        # Combina os relatórios
        echo '{"terraform": ' > /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-terraform.json >> /workspace/reports/checkov-report.json
        echo ', "kubernetes": ' >> /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-k8s.json >> /workspace/reports/checkov-report.json
        echo '}' >> /workspace/reports/checkov-report.json
        echo "Checkov scan completo"
    waitFor:
      - 'push'

  # 6 Container Scan (Trivy)
  - name: 'aquasec/trivy'
    id: 'trivy'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        trivy image \
          --format json \
          --output /workspace/reports/trivy-report.json \
          --db-repository ghcr.io/aquasecurity/trivy-db \
          --skip-db-update=false \
          ${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA || \
        echo '{"Results":[]}' > /workspace/reports/trivy-report.json
    waitFor:
      - 'push'

  # 7 Deploy do MySQL no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy-mysql'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/mysql.yaml
        echo "Aguardando o MySQL iniciar..."
        sleep 30
    waitFor:
      - 'trivy'


  # 8 Deploy do DVWA no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        # Substituir placeholder da imagem no YAML
        sed -i "s|us-central1-docker.pkg.dev/PROJECT_ID/artifact-repo/dvwa-app:latest|${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA|g" Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        # Aplicar o deployment
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        echo "Aguardando pods ficarem prontos..."
        kubectl rollout status deployment/${_DEPLOYMENT_NAME} --timeout=120s
    waitFor:
      - 'deploy-mysql'

  # 9 Obter IP externo do serviço para DAST
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-external-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        echo "Aguardando LoadBalancer obter IP externo..."
        for i in {1..30}; do
          EXTERNAL_IP=$$(kubectl get svc dvwa-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -n "$$EXTERNAL_IP" ] && [ "$$EXTERNAL_IP" != "" ]; then
            echo "IP externo obtido: $$EXTERNAL_IP"
            echo "$$EXTERNAL_IP" > /workspace/external_ip.txt
            break
          fi
          echo "Tentativa $$i/30 - Aguardando IP..."
          sleep 10
        done
        if [ ! -f /workspace/external_ip.txt ]; then
          echo "ERRO: Não foi possível obter IP externo"
          echo "UNAVAILABLE" > /workspace/external_ip.txt
        fi
    waitFor:
      - 'deploy'

  # 9.1 Configurar DVWA - Inicializar DB e definir nível de segurança LOW
  # Necessário para que as vulnerabilidades sejam detectáveis pelo DAST
  - name: 'curlimages/curl:latest'
    id: 'setup-dvwa'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "IP não disponível, pulando setup do DVWA"
          exit 0
        fi
        
        TARGET="http://$$EXTERNAL_IP"
        echo "=== Configurando DVWA em $$TARGET ==="
        
        # Aguardar DVWA inicializar
        echo "Aguardando DVWA ficar disponível..."
        for i in 1 2 3 4 5 6 7 8 9 10 11 12; do
          if curl -s --connect-timeout 5 "$$TARGET" > /dev/null 2>&1; then
            echo "DVWA acessível!"
            break
          fi
          echo "Tentativa $$i/12..."
          sleep 10
        done
        
        # 1. Inicializar banco de dados
        echo "=== Inicializando banco de dados ==="
        curl -s "$$TARGET/setup.php" -o /dev/null
        curl -s -X POST "$$TARGET/setup.php" -d "create_db=Create+/+Reset+Database" -o /dev/null
        sleep 5
        
        # 2. Fazer login para obter sessão
        echo "=== Fazendo login ==="
        COOKIE_FILE="/tmp/dvwa_cookies.txt"
        
        # Obter página de login e token CSRF
        LOGIN_PAGE=$$(curl -s -c "$$COOKIE_FILE" "$$TARGET/login.php")
        TOKEN=$$(echo "$$LOGIN_PAGE" | grep -oE "user_token' value='[^']+'" | sed "s/user_token' value='//;s/'//")
        
        if [ -z "$$TOKEN" ]; then
          echo "AVISO: Não foi possível obter token CSRF"
          TOKEN="dummy"
        fi
        echo "Token CSRF: $$TOKEN"
        
        # Fazer login
        curl -s -L -c "$$COOKIE_FILE" -b "$$COOKIE_FILE" \
          -d "username=admin&password=password&Login=Login&user_token=$$TOKEN" \
          "$$TARGET/login.php" -o /dev/null
        
        # 3. Configurar nível de segurança para LOW
        echo "=== Configurando nível LOW ==="
        SEC_PAGE=$$(curl -s -b "$$COOKIE_FILE" "$$TARGET/security.php")
        SEC_TOKEN=$$(echo "$$SEC_PAGE" | grep -oE "user_token' value='[^']+'" | sed "s/user_token' value='//;s/'//")
        
        if [ -z "$$SEC_TOKEN" ]; then
          SEC_TOKEN="$$TOKEN"
        fi
        
        curl -s -b "$$COOKIE_FILE" \
          -d "security=low&seclev_submit=Submit&user_token=$$SEC_TOKEN" \
          "$$TARGET/security.php" -o /dev/null
        
        # Verificar configuração
        VERIFY=$$(curl -s -b "$$COOKIE_FILE" "$$TARGET/security.php")
        if echo "$$VERIFY" | grep -q "selected.*low\|low.*selected"; then
          echo "✅ DVWA configurado para nível LOW"
        else
          echo "⚠️ Não foi possível confirmar nível LOW"
        fi
        
        echo "=== Setup do DVWA concluído ==="
    waitFor:
      - 'get-external-ip'

  # 10 DAST com OWASP ZAP (testes dinâmicos de segurança)
  # NOTA: Usa docker para montar /workspace/reports como /zap/wrk
  - name: 'gcr.io/cloud-builders/docker'
    id: 'zap-scan'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando scan DAST"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-report.json
          exit 0
        fi
        TARGET_URL="http://$$EXTERNAL_IP"
        echo "Alvo do scan DAST: $$TARGET_URL"
        
        # Aguardar app ficar disponível
        echo "Verificando se DVWA está acessível..."
        for i in {1..12}; do
          if curl -s --connect-timeout 5 "$$TARGET_URL" > /dev/null 2>&1; then
            echo "DVWA está acessível!"
            break
          fi
          echo "Tentativa $$i/12 - Aguardando DVWA..."
          sleep 10
        done
        
        # Executar ZAP via Docker com volume montado (rodar como root para permissões)
        echo "Iniciando OWASP ZAP Baseline Scan..."
        docker run --rm \
          -u 0 \
          -v /workspace/reports:/zap/wrk:rw \
          -t ghcr.io/zaproxy/zaproxy:stable \
          zap-full-scan.py -t "$$TARGET_URL" -r zap-report.html -J zap-report.json -I || true
        
        echo "Scan ZAP concluído"
        ls -la /workspace/reports/zap* 2>/dev/null || echo "Nenhum relatório ZAP encontrado"
    waitFor:
      - 'setup-dvwa'

  # 11 ZAP autenticado + active scan com sessão HTTP configurada
  - name: 'gcr.io/cloud-builders/docker'
    id: 'zap-auth-active-scan'
    entrypoint: 'bash'
    args:
      - -c
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        [ "$$EXTERNAL_IP" = "UNAVAILABLE" ] && echo '{"error":"IP indisponivel"}' > /workspace/reports/zap-auth-active-report.json && exit 0
        TARGET="http://$$EXTERNAL_IP"
        
        docker run --rm -u 0 -v /workspace/reports:/zap/wrk:rw \
          -e T="$$TARGET" -e U="${_DVWA_USER}" -e P="${_DVWA_PASS}" \
          ghcr.io/zaproxy/zaproxy:stable bash -c "
          ZAP=http://localhost:8090
          zap.sh -daemon -port 8090 -config api.disablekey=true &
          for i in \$$(seq 1 30); do curl -s \$$ZAP/JSON/core/view/version/ >/dev/null && break; sleep 2; done
          
          CF=/tmp/c.txt; curl -sc \$$CF \$$T/login.php -o /dev/null
          TK=\$$(curl -sb \$$CF \$$T/login.php | grep -oE 'user_token. value=.[^.]+' | sed 's/.*=.//;s/.\$$//' | head -1)
          curl -sLcb \$$CF -d \"username=\$$U&password=\$$P&Login=Login&user_token=\$$TK\" \$$T/login.php -o /dev/null
          SID=\$$(grep PHPSESSID \$$CF | awk '{print \$$NF}')
          echo Session: \$$SID
          
          curl -s \"\$$ZAP/JSON/replacer/action/addRule/?description=auth&enabled=true&matchType=REQ_HEADER&matchRegex=false&matchString=Cookie&replacement=PHPSESSID=\$$SID;%20security=low&initiators=\" -o /dev/null
          
          for u in /vulnerabilities/sqli/?id=1 /vulnerabilities/xss_r/?name=t /vulnerabilities/exec/?ip=1; do
            curl -s \"\$$ZAP/JSON/core/action/accessUrl/?url=\$$T\$$u&followRedirects=true\" -o /dev/null
          done
          
          curl -s \$$ZAP/JSON/spider/action/scan/?url=\$$T&recurse=true -o /dev/null
          for i in \$$(seq 1 24); do
            ST=\$$(curl -s \$$ZAP/JSON/spider/view/status/?scanId=0 | grep -oP 'status...\\K[0-9]+' || echo 0)
            [ \"\$$ST\" = \"100\" ] && break; sleep 5
          done
          
          curl -s \$$ZAP/JSON/ascan/action/enableAllScanners/ -o /dev/null
          curl -s \"\$$ZAP/JSON/ascan/action/scan/?url=\$$T&recurse=true&inScopeOnly=false\" -o /dev/null
          TO=0
          for i in \$$(seq 1 60); do
            ST=\$$(curl -s \$$ZAP/JSON/ascan/view/status/?scanId=0 | grep -oP 'status...\\K[0-9]+' || echo 0)
            echo Active: \$$ST%
            [ \"\$$ST\" = \"100\" ] && break
            sleep 10
            [ \$$i -eq 60 ] && TO=1
          done
          
          AL=\$$(curl -s \"\$$ZAP/JSON/core/view/alerts/?baseurl=\$$T&start=0&count=1000\")
          if [ \"\$$TO\" = \"1\" ]; then
            echo '{\"timeout\":true,\"alerts\":'\$$(echo \$$AL | jq .alerts)'}' > /zap/wrk/zap-auth-active-report.json
          else
            echo \$$AL > /zap/wrk/zap-auth-active-report.json
          fi
          curl -s \$$ZAP/OTHER/core/other/htmlreport/ > /zap/wrk/zap-auth-active-report.html
          echo Alertas: \$$(curl -s \$$ZAP/JSON/core/view/numberOfAlerts/?baseurl=\$$T)
          "
        ls -la /workspace/reports/zap-auth-* 2>/dev/null || echo "Sem relatorio"
    waitFor:
      - 'zap-scan'

  # 12 Teste de Brute Force com Script Python Customizado
  # O Hydra padrão não funciona com o DVWA porque o formulário de login
  # requer um token CSRF (user_token) que é regenerado a cada requisição.
  # Este script Python lida corretamente com o token CSRF.
  - name: 'python:3.11-slim'
    id: 'bruteforce-attack'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando brute force"
          echo '{"error": "IP não disponível", "vulnerable": false}' > /workspace/reports/hydra-bruteforce.json
          exit 0
        fi
        
        echo "=============================================="
        echo "DVWA Brute Force Attack (com suporte a CSRF)"
        echo "=============================================="
        echo "Alvo: http://$$EXTERNAL_IP"
        echo ""
        
        # Executa o script de brute force customizado
        python3 /workspace/Instrumentos/Codigos/DevSecOps/dvwa-bruteforce.py \
          "$$EXTERNAL_IP" \
          "/workspace/reports/hydra-bruteforce.json"
        
        echo ""
        echo "Brute force concluído!"
        echo "Relatório salvo em: /workspace/reports/hydra-bruteforce.json"
    waitFor:
      - 'get-external-ip'

  # 13 Upload dos relatórios de segurança para bucket GCS
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'upload-reports'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Relatórios gerados ==="
        ls -la /workspace/reports/
        # Nome da pasta: reports-<commit> (ex: reports-fbce037)
        if [ -d "/workspace/reports" ]; then
          gsutil -m cp -r /workspace/reports/* ${_REPORT_BUCKET}/reports-${SHORT_SHA}/
          echo "=============================================="
          echo "Relatórios salvos em: ${_REPORT_BUCKET}/reports-${SHORT_SHA}/"
          echo "=============================================="
        else
          echo "Nenhum relatório gerado."
        fi
    waitFor:
      - 'zap-scan'
      - 'zap-auth-active-scan'
      - 'semgrep'
      - 'sca-scan'
      - 'checkov'
      - 'trivy'
      - 'bruteforce-attack'

  # 14 Exibir IP externo do DVWA
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-service-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl get svc dvwa-service -o wide
    waitFor:
      - 'deploy'


images:
  - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'

options:
  dynamicSubstitutions: true
  defaultLogsBucketBehavior: REGIONAL_USER_OWNED_BUCKET
