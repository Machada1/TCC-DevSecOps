
# cloudbuild.yaml
# Pipeline completo: build -> push -> segurança -> deploy -> teste dinâmico
substitutions:
  _ARTIFACT_REPO: "devsecops-repo"
  _REGION: "us-central1"
  _PROJECT_ID: "infra-sd-host"
  _CLUSTER_NAME: "devsecops-cluster"
  _APP_NAME: "dvwa-app"
  _DEPLOYMENT_NAME: "dvwa-app"
  _REPORT_BUCKET: "gs://devsecops-reports-dvwa"
  _LOGS_BUCKET: "gs://infra-sd-host-cloudbuild-logs"
  _SOURCE_IMAGE: "vulnerables/web-dvwa:latest"
  _DVWA_USER: "admin"
  _DVWA_PASS: "password"

steps:
  # 0 Criar diretório de relatórios
  - name: 'ubuntu'
    id: 'setup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        mkdir -p /workspace/reports/dependency-check
        echo "Diretório de relatórios criado"

  # 1 Pull da imagem DVWA pública
  - name: 'gcr.io/cloud-builders/docker'
    id: 'pull-dvwa'
    args:
      - 'pull'
      - '${_SOURCE_IMAGE}'
    waitFor: ['setup']

  # 2 Tag e push da imagem para o Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-dvwa'
    args:
      - 'tag'
      - '${_SOURCE_IMAGE}'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['pull-dvwa']

  - name: 'gcr.io/cloud-builders/docker'
    id: 'push'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'
    waitFor: ['push-dvwa']
    
  # 3 SAST com Semgrep (análise estática do código PHP do DVWA)
  - name: 'returntocorp/semgrep:latest'
    id: 'semgrep'
    entrypoint: 'semgrep'
    args:
      - '--config'
      - 'auto'
      - '--config'
      - 'p/php'              # Regras específicas PHP
      - '--config'
      - 'p/security-audit'   # Auditoria de segurança
      - '--config'
      - 'p/owasp-top-ten'    # OWASP Top 10
      - '--json'
      - '--output'
      - '/workspace/reports/semgrep-report.json'
      - 'Instrumentos/Codigos/DevSecOps/dvwa/src'  # Código-fonte DVWA
    waitFor:
      - 'push'

  # 4 SCA - Análise de Composição de Software

  # NOTA: OWASP Dependency-Check comentado pois sem NVD API Key o download
  # da base de vulnerabilidades leva várias horas, inviabilizando o pipeline.
  # Para usar, obtenha uma API key gratuita em: https://nvd.nist.gov/developers/request-an-api-key
  # e adicione o argumento: '--nvdApiKey', '${_NVD_API_KEY}'
  #
  # - name: 'owasp/dependency-check'
  #   id: 'dependency-check'
  #   args:
  #     - '--scan'
  #     - '.'
  #     - '--format'
  #     - 'ALL'
  #     - '--out'
  #     - '/workspace/reports/dependency-check'
  #   waitFor:
  #     - 'push'
  
  # Alternativa: Trivy FS para SCA (mais rápido, usa base própria)
  # Analisa código-fonte DVWA para encontrar dependências vulneráveis
  - name: 'aquasec/trivy'
    id: 'sca-scan'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        trivy fs \
          --scanners vuln,secret \
          --format json \
          --output /workspace/reports/trivy-sca-report.json \
          --db-repository ghcr.io/aquasecurity/trivy-db \
          --skip-db-update=false \
          Instrumentos/Codigos/DevSecOps/dvwa/src || \
        echo '{"Results":[]}' > /workspace/reports/trivy-sca-report.json
    waitFor:
      - 'push'

  # 5 IaC Scan (Terraform) com Checkov
  - name: 'bridgecrew/checkov:latest'
    id: 'checkov'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Escaneia tanto o Terraform quanto os manifests Kubernetes
        checkov -d ./Instrumentos/Codigos/DevSecOps/infra -o json > /workspace/reports/checkov-terraform.json || true
        checkov -d ./Instrumentos/Codigos/DevSecOps/dvwa/k8s -o json > /workspace/reports/checkov-k8s.json || true
        # Combina os relatórios
        echo '{"terraform": ' > /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-terraform.json >> /workspace/reports/checkov-report.json
        echo ', "kubernetes": ' >> /workspace/reports/checkov-report.json
        cat /workspace/reports/checkov-k8s.json >> /workspace/reports/checkov-report.json
        echo '}' >> /workspace/reports/checkov-report.json
        echo "Checkov scan completo"
    waitFor:
      - 'push'

  # 6 Container Scan (Trivy)
  - name: 'aquasec/trivy'
    id: 'trivy'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        trivy image \
          --format json \
          --output /workspace/reports/trivy-report.json \
          --db-repository ghcr.io/aquasecurity/trivy-db \
          --skip-db-update=false \
          ${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA || \
        echo '{"Results":[]}' > /workspace/reports/trivy-report.json
    waitFor:
      - 'push'

  # 7 Deploy do MySQL no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy-mysql'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/mysql.yaml
        echo "Aguardando o MySQL iniciar..."
        sleep 30
    waitFor:
      - 'trivy'


  # 8 Deploy do DVWA no GKE
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        # Substituir placeholder da imagem no YAML
        sed -i "s|us-central1-docker.pkg.dev/PROJECT_ID/artifact-repo/dvwa-app:latest|${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA|g" Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        # Aplicar o deployment
        kubectl apply -f Instrumentos/Codigos/DevSecOps/dvwa/k8s/dvwa.yaml
        echo "Aguardando pods ficarem prontos..."
        kubectl rollout status deployment/${_DEPLOYMENT_NAME} --timeout=120s
    waitFor:
      - 'deploy-mysql'

  # 9 Obter IP externo do serviço para DAST
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-external-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        echo "Aguardando LoadBalancer obter IP externo..."
        for i in {1..30}; do
          EXTERNAL_IP=$$(kubectl get svc dvwa-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -n "$$EXTERNAL_IP" ] && [ "$$EXTERNAL_IP" != "" ]; then
            echo "IP externo obtido: $$EXTERNAL_IP"
            echo "$$EXTERNAL_IP" > /workspace/external_ip.txt
            break
          fi
          echo "Tentativa $$i/30 - Aguardando IP..."
          sleep 10
        done
        if [ ! -f /workspace/external_ip.txt ]; then
          echo "ERRO: Não foi possível obter IP externo"
          echo "UNAVAILABLE" > /workspace/external_ip.txt
        fi
    waitFor:
      - 'deploy'

  # 9.1 Configurar DVWA - Inicializar DB e definir nível de segurança LOW
  # Necessário para que as vulnerabilidades sejam detectáveis pelo DAST
  - name: 'curlimages/curl:latest'
    id: 'setup-dvwa'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "IP não disponível, pulando setup do DVWA"
          exit 0
        fi
        
        TARGET="http://$$EXTERNAL_IP"
        echo "=== Configurando DVWA em $$TARGET ==="
        
        # Aguardar DVWA inicializar
        echo "Aguardando DVWA ficar disponível..."
        for i in 1 2 3 4 5 6 7 8 9 10 11 12; do
          if curl -s --connect-timeout 5 "$$TARGET" > /dev/null 2>&1; then
            echo "DVWA acessível!"
            break
          fi
          echo "Tentativa $$i/12..."
          sleep 10
        done
        
        # 1. Inicializar banco de dados
        echo "=== Inicializando banco de dados ==="
        curl -s "$$TARGET/setup.php" -o /dev/null
        curl -s -X POST "$$TARGET/setup.php" -d "create_db=Create+/+Reset+Database" -o /dev/null
        sleep 5
        
        # 2. Fazer login para obter sessão
        echo "=== Fazendo login ==="
        COOKIE_FILE="/tmp/dvwa_cookies.txt"
        
        # Obter página de login e token CSRF
        LOGIN_PAGE=$$(curl -s -c "$$COOKIE_FILE" "$$TARGET/login.php")
        TOKEN=$$(echo "$$LOGIN_PAGE" | grep -oE "user_token' value='[^']+'" | sed "s/user_token' value='//;s/'//")
        
        if [ -z "$$TOKEN" ]; then
          echo "AVISO: Não foi possível obter token CSRF"
          TOKEN="dummy"
        fi
        echo "Token CSRF: $$TOKEN"
        
        # Fazer login
        curl -s -L -c "$$COOKIE_FILE" -b "$$COOKIE_FILE" \
          -d "username=admin&password=password&Login=Login&user_token=$$TOKEN" \
          "$$TARGET/login.php" -o /dev/null
        
        # 3. Configurar nível de segurança para LOW
        echo "=== Configurando nível LOW ==="
        SEC_PAGE=$$(curl -s -b "$$COOKIE_FILE" "$$TARGET/security.php")
        SEC_TOKEN=$$(echo "$$SEC_PAGE" | grep -oE "user_token' value='[^']+'" | sed "s/user_token' value='//;s/'//")
        
        if [ -z "$$SEC_TOKEN" ]; then
          SEC_TOKEN="$$TOKEN"
        fi
        
        curl -s -b "$$COOKIE_FILE" \
          -d "security=low&seclev_submit=Submit&user_token=$$SEC_TOKEN" \
          "$$TARGET/security.php" -o /dev/null
        
        # Verificar configuração
        VERIFY=$$(curl -s -b "$$COOKIE_FILE" "$$TARGET/security.php")
        if echo "$$VERIFY" | grep -q "selected.*low\|low.*selected"; then
          echo "✅ DVWA configurado para nível LOW"
        else
          echo "⚠️ Não foi possível confirmar nível LOW"
        fi
        
        echo "=== Setup do DVWA concluído ==="
    waitFor:
      - 'get-external-ip'

  # 10 DAST com OWASP ZAP (testes dinâmicos de segurança)
  # NOTA: Usa docker para montar /workspace/reports como /zap/wrk
  - name: 'gcr.io/cloud-builders/docker'
    id: 'zap-scan'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando scan DAST"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-report.json
          exit 0
        fi
        TARGET_URL="http://$$EXTERNAL_IP"
        echo "Alvo do scan DAST: $$TARGET_URL"
        
        # Aguardar app ficar disponível
        echo "Verificando se DVWA está acessível..."
        for i in {1..12}; do
          if curl -s --connect-timeout 5 "$$TARGET_URL" > /dev/null 2>&1; then
            echo "DVWA está acessível!"
            break
          fi
          echo "Tentativa $$i/12 - Aguardando DVWA..."
          sleep 10
        done
        
        # Executar ZAP via Docker com volume montado (rodar como root para permissões)
        echo "Iniciando OWASP ZAP Baseline Scan..."
        docker run --rm \
          -u 0 \
          -v /workspace/reports:/zap/wrk:rw \
          -t ghcr.io/zaproxy/zaproxy:stable \
          zap-full-scan.py -t "$$TARGET_URL" -r zap-report.html -J zap-report.json -I || true
        
        echo "Scan ZAP concluído"
        ls -la /workspace/reports/zap* 2>/dev/null || echo "Nenhum relatório ZAP encontrado"
    waitFor:
      - 'setup-dvwa'

  # 11 ZAP autenticado + active scan (usando docker run com root para ter permissão de escrita)
  - name: 'gcr.io/cloud-builders/docker'
    id: 'zap-auth-active-scan'
    entrypoint: 'bash'
    args:
      - -c
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando ZAP autenticado"
          echo '{"error": "IP externo não disponível"}' > /workspace/reports/zap-auth-active-report.json
          exit 0
        fi
        
        TARGET_URL="http://$$EXTERNAL_IP"
        
        echo "=== Iniciando ZAP Active Scan Autenticado ==="
        echo "Alvo: $$TARGET_URL"
        
        # Executa ZAP via docker com usuário root (-u 0)
        # TODAS as variáveis dentro do bash -c precisam de $$ para escapar do Cloud Build
        docker run --rm \
          -u 0 \
          -v /workspace/reports:/zap/wrk:rw \
          -e TARGET_URL="$$TARGET_URL" \
          -e EXTERNAL_IP="$$EXTERNAL_IP" \
          -e DVWA_USER="${_DVWA_USER}" \
          -e DVWA_PASS="${_DVWA_PASS}" \
          ghcr.io/zaproxy/zaproxy:stable \
          bash -c '
            ZAP_API="http://localhost:8090"
            
            echo "=== Iniciando ZAP daemon ==="
            zap.sh -daemon -port 8090 -host 0.0.0.0 -config api.disablekey=true &
            
            echo "Aguardando ZAP iniciar..."
            for i in $$(seq 1 60); do
              if curl -s "$$ZAP_API/JSON/core/view/version/" > /dev/null 2>&1; then
                echo "ZAP iniciado!"
                break
              fi
              sleep 2
            done
            
            ZAP_VERSION=$$(curl -s "$$ZAP_API/JSON/core/view/version/" 2>/dev/null || echo "erro")
            echo "ZAP: $$ZAP_VERSION"
            
            if echo "$$ZAP_VERSION" | grep -q "erro"; then
              echo "{\"error\": \"ZAP nao iniciou\"}" > /zap/wrk/zap-auth-active-report.json
              exit 0
            fi
            
            echo "=== Login no DVWA ==="
            # Obter página de login para pegar CSRF token
            LOGIN_PAGE=$$(curl -s -c /tmp/cookies.txt "$$TARGET_URL/login.php")
            CSRF_TOKEN=$$(echo "$$LOGIN_PAGE" | grep -oE "user_token. value=.[^.]+" | head -1 | sed "s/.*value=.//;s/.$$//")
            echo "CSRF Token: $$CSRF_TOKEN"
            
            # Fazer login com token CSRF
            curl -s -L -c /tmp/cookies.txt -b /tmp/cookies.txt \
              -d "username=$$DVWA_USER&password=$$DVWA_PASS&Login=Login&user_token=$$CSRF_TOKEN" \
              "$$TARGET_URL/login.php" -o /dev/null
            
            # Verificar login
            INDEX=$$(curl -s -b /tmp/cookies.txt "$$TARGET_URL/index.php")
            if echo "$$INDEX" | grep -q "Welcome"; then
              echo "✅ Login bem-sucedido!"
            else
              echo "⚠️ Login pode ter falhado"
            fi
            
            echo "=== Acessando URLs vulneráveis do DVWA ==="
            # Acessar cada página vulnerável para o Spider indexar
            VULN_URLS="
              /vulnerabilities/sqli/?id=1&Submit=Submit
              /vulnerabilities/sqli_blind/?id=1&Submit=Submit
              /vulnerabilities/xss_r/?name=test
              /vulnerabilities/xss_s/
              /vulnerabilities/exec/?ip=127.0.0.1&Submit=Submit
              /vulnerabilities/fi/?page=include.php
              /vulnerabilities/upload/
              /vulnerabilities/csrf/
              /vulnerabilities/brute/
              /vulnerabilities/captcha/
              /vulnerabilities/weak_id/
            "
            
            for url in $$VULN_URLS; do
              echo "Acessando: $$TARGET_URL$$url"
              curl -s -b /tmp/cookies.txt "$$TARGET_URL$$url" -o /dev/null
              # Informar ZAP sobre a URL
              curl -s "$$ZAP_API/JSON/core/action/accessUrl/?url=$$TARGET_URL$$url&followRedirects=true" -o /dev/null
            done
            
            echo "=== Executando Spider ==="
            SPIDER_RESP=$$(curl -s "$$ZAP_API/JSON/spider/action/scan/?url=$$TARGET_URL&recurse=true")
            SPIDER_ID=$$(echo "$$SPIDER_RESP" | grep -oP "\"scan\":\"\\K[0-9]+" || echo "")
            echo "Spider ID: $$SPIDER_ID"
            
            if [ -n "$$SPIDER_ID" ]; then
              for i in $$(seq 1 36); do
                STATUS=$$(curl -s "$$ZAP_API/JSON/spider/view/status/?scanId=$$SPIDER_ID" | grep -oP "\"status\":\"\\K[0-9]+" || echo "0")
                echo "Spider: $$STATUS%"
                [ "$$STATUS" = "100" ] && break
                sleep 5
              done
            fi
            
            echo "=== Executando Active Scan ==="
            ASCAN_RESP=$$(curl -s "$$ZAP_API/JSON/ascan/action/scan/?url=$$TARGET_URL&recurse=true&inScopeOnly=false")
            ASCAN_ID=$$(echo "$$ASCAN_RESP" | grep -oP "\"scan\":\"\\K[0-9]+" || echo "")
            echo "Active Scan ID: $$ASCAN_ID"
            
            if [ -n "$$ASCAN_ID" ]; then
              for i in $$(seq 1 60); do
                STATUS=$$(curl -s "$$ZAP_API/JSON/ascan/view/status/?scanId=$$ASCAN_ID" | grep -oP "\"status\":\"\\K[0-9]+" || echo "0")
                echo "Active Scan: $$STATUS%"
                [ "$$STATUS" = "100" ] && break
                sleep 10
              done
            fi
            
            echo "=== Gerando Relatórios ==="
            curl -s "$$ZAP_API/JSON/core/view/alerts/?baseurl=$$TARGET_URL&start=0&count=1000" > /zap/wrk/zap-auth-active-report.json
            curl -s "$$ZAP_API/OTHER/core/other/htmlreport/" > /zap/wrk/zap-auth-active-report.html
            
            echo "=== Resumo ==="
            ALERTS=$$(curl -s "$$ZAP_API/JSON/core/view/numberOfAlerts/?baseurl=$$TARGET_URL" | grep -oP "\"numberOfAlerts\":\"\\K[0-9]+" || echo "0")
            echo "Total de alertas: $$ALERTS"
            curl -s "$$ZAP_API/JSON/core/view/alertsSummary/?baseurl=$$TARGET_URL"
            
            ls -la /zap/wrk/zap-auth-*
            echo "=== Concluído ==="
          '
        
        echo "=== Verificando relatórios gerados ==="
        ls -la /workspace/reports/zap-auth-* 2>/dev/null || echo "Nenhum relatório encontrado"
    waitFor:
      - 'zap-scan'

  # 12 Teste de Brute Force com Script Python Customizado
  # O Hydra padrão não funciona com o DVWA porque o formulário de login
  # requer um token CSRF (user_token) que é regenerado a cada requisição.
  # Este script Python lida corretamente com o token CSRF.
  - name: 'python:3.11-slim'
    id: 'bruteforce-attack'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        EXTERNAL_IP=$$(cat /workspace/external_ip.txt)
        if [ "$$EXTERNAL_IP" = "UNAVAILABLE" ]; then
          echo "ERRO: IP externo não disponível, pulando brute force"
          echo '{"error": "IP não disponível", "vulnerable": false}' > /workspace/reports/hydra-bruteforce.json
          exit 0
        fi
        
        echo "=============================================="
        echo "DVWA Brute Force Attack (com suporte a CSRF)"
        echo "=============================================="
        echo "Alvo: http://$$EXTERNAL_IP"
        echo ""
        
        # Executa o script de brute force customizado
        python3 /workspace/Instrumentos/Codigos/DevSecOps/dvwa-bruteforce.py \
          "$$EXTERNAL_IP" \
          "/workspace/reports/hydra-bruteforce.json"
        
        echo ""
        echo "Brute force concluído!"
        echo "Relatório salvo em: /workspace/reports/hydra-bruteforce.json"
    waitFor:
      - 'get-external-ip'

  # 13 Upload dos relatórios de segurança para bucket GCS
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'upload-reports'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Relatórios gerados ==="
        ls -la /workspace/reports/
        # Nome da pasta: reports-<commit> (ex: reports-fbce037)
        if [ -d "/workspace/reports" ]; then
          gsutil -m cp -r /workspace/reports/* ${_REPORT_BUCKET}/reports-${SHORT_SHA}/
          echo "=============================================="
          echo "Relatórios salvos em: ${_REPORT_BUCKET}/reports-${SHORT_SHA}/"
          echo "=============================================="
        else
          echo "Nenhum relatório gerado."
        fi
    waitFor:
      - 'zap-scan'
      - 'zap-auth-active-scan'
      - 'semgrep'
      - 'sca-scan'
      - 'checkov'
      - 'trivy'
      - 'bruteforce-attack'

  # 14 Exibir IP externo do DVWA
  - name: 'gcr.io/cloud-builders/kubectl'
    id: 'get-service-ip'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} --region ${_REGION} --project ${_PROJECT_ID}
        kubectl get svc dvwa-service -o wide
    waitFor:
      - 'deploy'


images:
  - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_ARTIFACT_REPO}/${_APP_NAME}:$SHORT_SHA'

options:
  dynamicSubstitutions: true
  defaultLogsBucketBehavior: REGIONAL_USER_OWNED_BUCKET
